/*
 * Copyright (c) 2017, Heriot-Watt University, Edinburgh
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the IRISA nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Author: Ross Brunton <bruntonross@gmail.com>
 * Date: 23.02.2017
 * See Gradient.md for documentation.
 */

package image.hog_person_detector;

import image.constants.constants.*;

actor Gradient() uint(size=8) Gin ==> uint(size=8) Grad :
    uint(size=8) WIDTH = 8;
    uint(size=8) HEIGHT = 8;
    uint(size=32) SIZE = WIDTH * HEIGHT;
    float RADFACTOR = 180 / 3.14;
    uint(size=8) buff[SIZE];
    uint(size=32) rp := 0;
    uint(size=32) op := 0;
    uint(size=8) angle := 0;
    uint(size=8) mag := 0;
    uint(size=32) out := 0;

    function Get (uint(size=8) x, uint(size=8) y, uint(size=8) ox, uint(size=8) oy) --> uint(size=16):
        if x < 0 || y < 0 || x > WIDTH || y > HEIGHT then
            buff[oy * WIDTH + ox]
        else
            buff[y * WIDTH + y]
        end
    end

    function Abs(int(size=16) val) --> uint(size=16):
        if val < 0 then -val else val end
    end

    // Proceducre shamelessly copied from segmentation.edgeDetection.Sobel;
    procedure Sqrt(int num)
    var
        int op := num,
        int one := (1 << 14), // The second-to-top bit is set: 1L<<30 for long
        int lres := 0
    begin
        // "one" starts at the highest power of four <= the argument.
        while (one > op) do
           one := (one >> 2);
        end

        while (one != 0) do
          if (op >= lres + one) then
            op := op - (lres + one);
            lres := lres + (one << 1);
          end
          lres := (lres >> 1);
          one := (one >> 2);
        end

        out := lres;
    end

    // TODO
    // Returns rads * 100, btw
    procedure Arctan(int(size=16) o, int(size=16)a)
    begin
        out := 1;
    end

    reset: action ==>
    guard rp = SIZE && op = SIZE
    do
        rp := 0;
        op := 0;
    end

    read: action Gin:[val] ==>
    guard rp < SIZE
    do
        buff[rp] := val;
        rp := rp + 1;
    end

    write: action ==> Grad:[angle, mag]
    guard rp = SIZE && op < SIZE
    var
        uint(size=8) val,
        uint(size=8) x,
        uint(size=8) y,
        int(size=16) dx,
        int(size=16) dy,
        int(size=32) tmp
    do
        val := buff[op];
        x := op mod WIDTH;
        y := op / WIDTH;

        dy := Get(x, y - 1, x, y) - Get(x, y + 1, x, y);
        dx := Get(x - 1, y, x, y) - Get(x + 1, y, x, y);

        // Calculate magnitude
        Sqrt(dx * dx + dy * dy);
        mag := out;

        println("Mag: "+dx + ", "+dy + " = " + mag);

        // Calculate angle
        Arctan(dy, dx);
        tmp := ((out * 18000) / 314);
        angle := tmp / 200;

        op := op + 1;
    end
end
